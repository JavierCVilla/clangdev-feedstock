From a283dc5847f812a08a08de03b0a733d4ea51b561 Mon Sep 17 00:00:00 2001
From: Philippe Canal <pcanal@fnal.gov>
Date: Mon, 25 Feb 2013 16:27:29 +0000
Subject: [PATCH] Intentionally ugly (but minimally invasive) hack. Enabling
 this hack makes the template substitution more permissive and allows for
 replacement with non-canonical types.  This is usefull in the case of client
 code emulating opaque typedefs and/or wanting to recover the template
 instance name as the user would have written if (s)he expanded the default
 paramater explicitly.   For example the user might have type:
 vector<Double32_t> and the client wants to see:   
 std::vector<Double32_t,std::allocator<Double32_t> >

git-svn-id: http://root.cern.ch/svn/root/trunk@48698 27541ba8-7e3a-0410-8455-c3a389f83636
---
 .../clang/include/clang/AST/ASTContext.h      |  3 +-
 .../src/tools/clang/lib/AST/ASTContext.cpp    | 10 ++--
 .../lib/Sema/HackForDefaultTemplateArg.h      | 52 +++++++++++++++++++
 .../src/tools/clang/lib/Sema/SemaTemplate.cpp | 50 ++++++++++++++++--
 .../lib/Sema/SemaTemplateInstantiate.cpp      |  6 ++-
 .../src/tools/clang/lib/Sema/TreeTransform.h  |  4 +-
 6 files changed, 113 insertions(+), 12 deletions(-)
 create mode 100644 interpreter/llvm/src/tools/clang/lib/Sema/HackForDefaultTemplateArg.h

diff --git a/interpreter/llvm/src/tools/clang/include/clang/AST/ASTContext.h b/interpreter/llvm/src/tools/clang/include/clang/AST/ASTContext.h
index f52ee0470a5..82327d4c53c 100644
--- a/interpreter/llvm/src/tools/clang/include/clang/AST/ASTContext.h
+++ b/interpreter/llvm/src/tools/clang/include/clang/AST/ASTContext.h
@@ -963,7 +963,8 @@ class ASTContext : public RefCountedBase<ASTContext> {
                              QualType equivalentType);
 
   QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,
-                                        QualType Replacement) const;
+                                        QualType Replacement,
+                                        bool AllowNonCanonical = false) const;
   QualType getSubstTemplateTypeParmPackType(
                                           const TemplateTypeParmType *Replaced,
                                             const TemplateArgument &ArgPack);
diff --git a/interpreter/llvm/src/tools/clang/lib/AST/ASTContext.cpp b/interpreter/llvm/src/tools/clang/lib/AST/ASTContext.cpp
index 83f3f9ca119..5958f62fb75 100644
--- a/interpreter/llvm/src/tools/clang/lib/AST/ASTContext.cpp
+++ b/interpreter/llvm/src/tools/clang/lib/AST/ASTContext.cpp
@@ -2702,9 +2702,13 @@ QualType ASTContext::getAttributedType(AttributedType::Kind attrKind,
 /// \brief Retrieve a substitution-result type.
 QualType
 ASTContext::getSubstTemplateTypeParmType(const TemplateTypeParmType *Parm,
-                                         QualType Replacement) const {
-  assert(Replacement.isCanonical()
-         && "replacement types must always be canonical");
+                                         QualType Replacement,
+                                         bool AllowNonCanonical /* = false */
+                                        ) const {
+  if (!AllowNonCanonical) {
+     assert(Replacement.isCanonical()
+            && "replacement types must always be canonical");
+  }
 
   llvm::FoldingSetNodeID ID;
   SubstTemplateTypeParmType::Profile(ID, Parm, Replacement);
diff --git a/interpreter/llvm/src/tools/clang/lib/Sema/HackForDefaultTemplateArg.h b/interpreter/llvm/src/tools/clang/lib/Sema/HackForDefaultTemplateArg.h
new file mode 100644
index 00000000000..e6af62c414b
--- /dev/null
+++ b/interpreter/llvm/src/tools/clang/lib/Sema/HackForDefaultTemplateArg.h
@@ -0,0 +1,52 @@
+//===------- HackForDefaultTemplateArg.h - Make template argument substitution mroe permissive -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//===----------------------------------------------------------------------===//
+//
+//  Enabling this hack, make the template substitution more permissive and
+//  allows for replacement with non-canonical types.  This is usefull in the
+//  case of client code emulating opaque typedefs and/or wanting to recover
+//  the template instance name as the user would have written if (s)he 
+//  expanded the default paramater explicitly.   For example the user might
+//  have type: vector<int32_t> and the client wants to see:
+//  std::vector<int32_t,std::allocator<int32_t> >
+//
+//  For convenience purposes the implementation is located in
+//  SemaTemplate.cpp
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+#define LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+
+namespace clang {
+namespace sema {
+
+///  \brief Enabling this hack makes the template substitution more permissive
+///  and allows for replacement with non-canonical types.  This is usefull in
+///  the case of client code emulating opaque typedefs and/or wanting to recover
+///  the template instance name as the user would have written if (s)he
+///  expanded the default paramater explicitly.   For example the user might
+///  have type: \c vector<int32_t> and the client wants to see:
+///  \c std::vector<int32_t,std::allocator<int32_t> >
+   
+class HackForDefaultTemplateArg {
+  /// \brief Private RAII object that set and reset the hack state.
+
+  static bool AllowNonCanonicalSubstEnabled;
+  bool OldValue;
+public:
+
+  HackForDefaultTemplateArg();
+  ~HackForDefaultTemplateArg();
+  
+  static bool AllowNonCanonicalSubst();
+};
+  
+} // sema
+} // clang
+
+#endif // LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
diff --git a/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplate.cpp b/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplate.cpp
index 0efe710acc1..614843baa58 100644
--- a/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplate.cpp
+++ b/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplate.cpp
@@ -32,6 +32,31 @@
 using namespace clang;
 using namespace sema;
 
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled = true;
+
+// Default constructor, record the current value
+// of HackForDefaultTemplateArg::AllowNonCanonicalSubst
+// and set it to true.
+HackForDefaultTemplateArg::HackForDefaultTemplateArg() :
+  OldValue(HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled)
+{
+  AllowNonCanonicalSubstEnabled = true;
+}
+
+// Destructor, restore the previous value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+HackForDefaultTemplateArg::~HackForDefaultTemplateArg()
+{
+  AllowNonCanonicalSubstEnabled = OldValue;
+}
+
+// Return the current value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubst()
+{
+  return AllowNonCanonicalSubstEnabled;
+}
+
 // Exported for use by Parser.
 SourceRange
 clang::getTemplateParamsRange(TemplateParameterList const * const *Ps,
@@ -2513,8 +2538,12 @@ bool Sema::CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,
     return true;
 
   // Add the converted template type argument.
-  ArgType = Context.getCanonicalType(ArgType);
-  
+  if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    ArgType = Context.getCanonicalType(Arg.getAsType());
+  } else {
+    ArgType = Arg.getAsType().getCanonicalType();
+  }
+
   // Objective-C ARC:
   //   If an explicitly-specified template argument type is a lifetime type
   //   with no lifetime qualifier, the __strong lifetime qualifier is inferred.
@@ -3537,8 +3567,15 @@ bool Sema::CheckTemplateArgument(TemplateTypeParmDecl *Param,
 
   if (Arg->isVariablyModifiedType()) {
     return Diag(SR.getBegin(), diag::err_variably_modified_template_arg) << Arg;
-  } else if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
-    return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+  } else if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
+  } else {
+    if (Context.hasSameUnqualifiedType(Arg.getCanonicalType(),
+                                       Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
   }
 
   // C++03 [temp.arg.type]p2:
@@ -3555,7 +3592,11 @@ bool Sema::CheckTemplateArgument(TemplateTypeParmDecl *Param,
                                SR.getBegin()) != DiagnosticsEngine::Ignored :
       Arg->hasUnnamedOrLocalType()) {
     UnnamedLocalNoLinkageFinder Finder(*this, SR);
-    (void)Finder.Visit(Context.getCanonicalType(Arg));
+    if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+      (void)Finder.Visit(Context.getCanonicalType(Arg));
+    } else {
+      (void)Finder.Visit(Arg.getCanonicalType());
+    }
   }
 
   return false;
diff --git a/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplateInstantiate.cpp b/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplateInstantiate.cpp
index 665dd07b8f8..c4d6c916d31 100644
--- a/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplateInstantiate.cpp
+++ b/interpreter/llvm/src/tools/clang/lib/Sema/SemaTemplateInstantiate.cpp
@@ -1419,7 +1419,8 @@ TemplateInstantiator::TransformTemplateTypeParmType(TypeLocBuilder &TLB,
 
     // TODO: only do this uniquing once, at the start of instantiation.
     QualType Result
-      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement);
+      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement,
+                          HackForDefaultTemplateArg::AllowNonCanonicalSubst());
     SubstTemplateTypeParmTypeLoc NewTL
       = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
     NewTL.setNameLoc(TL.getNameLoc());
@@ -1465,7 +1466,8 @@ TemplateInstantiator::TransformSubstTemplateTypeParmPackType(
   QualType Result = ArgPack.pack_begin()[Index].getAsType();
   Result = getSema().Context.getSubstTemplateTypeParmType(
                                       TL.getTypePtr()->getReplacedParameter(),
-                                                          Result);
+                                                          Result,
+                           HackForDefaultTemplateArg::AllowNonCanonicalSubst());
   SubstTemplateTypeParmTypeLoc NewTL
     = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
   NewTL.setNameLoc(TL.getNameLoc());
diff --git a/interpreter/llvm/src/tools/clang/lib/Sema/TreeTransform.h b/interpreter/llvm/src/tools/clang/lib/Sema/TreeTransform.h
index f76c947e31f..f1b1bb6d6bb 100644
--- a/interpreter/llvm/src/tools/clang/lib/Sema/TreeTransform.h
+++ b/interpreter/llvm/src/tools/clang/lib/Sema/TreeTransform.h
@@ -36,6 +36,8 @@
 #include "TypeLocBuilder.h"
 #include <algorithm>
 
+#include "HackForDefaultTemplateArg.h"
+
 namespace clang {
 using namespace sema;
 
@@ -4493,7 +4495,7 @@ QualType TreeTransform<Derived>::TransformSubstTemplateTypeParmType(
   Replacement = SemaRef.Context.getCanonicalType(Replacement);
   QualType Result
     = SemaRef.Context.getSubstTemplateTypeParmType(T->getReplacedParameter(),
-                                                   Replacement);
+                                                   Replacement,false);
 
   // Propagate type-source information.
   SubstTemplateTypeParmTypeLoc NewTL
