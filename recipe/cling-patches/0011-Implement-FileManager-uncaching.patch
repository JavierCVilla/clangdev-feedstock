From b2817b48c72bda4c9c73af1e24eeaa868ef6f603 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <vvasilev@cern.ch>
Date: Tue, 17 Sep 2013 16:25:52 +0200
Subject: [PATCH 11/62] Implement FileManager uncaching.

If the file is marked for rereading and deleted in the meanwhile it will get different file stat and inode number. Teach the file manager to handle these situations.
---
 include/clang/Basic/FileManager.h   |  3 +++
 include/clang/Basic/SourceManager.h |  2 ++
 lib/Basic/FileManager.cpp           | 31 +++++++++++++++++++++--------
 lib/Basic/SourceManager.cpp         |  8 ++++++++
 lib/Serialization/ModuleManager.cpp |  4 +++-
 5 files changed, 39 insertions(+), 9 deletions(-)

diff --git a/include/clang/Basic/FileManager.h b/include/clang/Basic/FileManager.h
index b817dd20c3..cb0af36c43 100644
--- a/include/clang/Basic/FileManager.h
+++ b/include/clang/Basic/FileManager.h
@@ -29,6 +29,7 @@
 #include <memory>
 #include <map>
 #include <string>
+#include <set>
 
 namespace llvm {
 
@@ -147,6 +148,8 @@ class FileManager : public RefCountedBase<FileManager> {
   /// \see SeenDirEntries
   llvm::StringMap<FileEntry*, llvm::BumpPtrAllocator> SeenFileEntries;
 
+  std::set<const FileEntry*> FileEntriesToReread;
+
   /// \brief The canonical names of directories.
   llvm::DenseMap<const DirectoryEntry *, llvm::StringRef> CanonicalDirNames;
 
diff --git a/include/clang/Basic/SourceManager.h b/include/clang/Basic/SourceManager.h
index ed3f8dfa86..3ff942426e 100644
--- a/include/clang/Basic/SourceManager.h
+++ b/include/clang/Basic/SourceManager.h
@@ -735,6 +735,8 @@ public:
 
   void clearIDTables();
 
+  void invalidateCache(const FileEntry* Entry);
+
   /// Initialize this source manager suitably to replay the compilation
   /// described by \p Old. Requires that \p Old outlive \p *this.
   void initializeForReplay(const SourceManager &Old);
diff --git a/lib/Basic/FileManager.cpp b/lib/Basic/FileManager.cpp
index 0c10b5f4d1..c43f5ecf78 100644
--- a/lib/Basic/FileManager.cpp
+++ b/lib/Basic/FileManager.cpp
@@ -220,8 +220,20 @@ const FileEntry *FileManager::getFile(StringRef Filename, bool openFile,
   auto &NamedFileEnt =
       *SeenFileEntries.insert(std::make_pair(Filename, nullptr)).first;
 
+  const FileEntry *StaleFileEntry = 0;
+  bool needsRereading = false;
+  if (NamedFileEnt.getValue()) {
+    std::set<const FileEntry*>::const_iterator found
+      = FileEntriesToReread.find(NamedFileEnt.getValue());
+    if (found != FileEntriesToReread.end()) {
+      needsRereading = true;
+      StaleFileEntry = NamedFileEnt.getValue();
+      FileEntriesToReread.erase(found);
+    }
+  }
+
   // See if there is already an entry in the map.
-  if (NamedFileEnt.second)
+  if (NamedFileEnt.second && !needsRereading)
     return NamedFileEnt.second == NON_EXISTENT_FILE ? nullptr
                                                     : NamedFileEnt.second;
 
@@ -318,6 +330,15 @@ const FileEntry *FileManager::getFile(StringRef Filename, bool openFile,
   if (UFE.File)
     if (auto RealPathName = UFE.File->getName())
       UFE.RealPathName = *RealPathName;
+
+  if (StaleFileEntry) {
+    // Find occurrences of old FileEntry; update with new one:
+    for (auto& fe: SeenFileEntries) {
+      if (fe.getValue() == StaleFileEntry) {
+        fe.setValue(&UFE);
+      }
+    }
+  }
   return &UFE;
 }
 
@@ -492,13 +513,7 @@ bool FileManager::getNoncachedStatValue(StringRef Path,
 
 void FileManager::invalidateCache(const FileEntry *Entry) {
   assert(Entry && "Cannot invalidate a NULL FileEntry");
-
-  SeenFileEntries.erase(Entry->getName());
-
-  // FileEntry invalidation should not block future optimizations in the file
-  // caches. Possible alternatives are cache truncation (invalidate last N) or
-  // invalidation of the whole cache.
-  UniqueRealFiles.erase(Entry->getUniqueID());
+  FileEntriesToReread.insert(Entry);
 }
 
 void FileManager::GetUniqueIDMapping(
diff --git a/lib/Basic/SourceManager.cpp b/lib/Basic/SourceManager.cpp
index f0b53b4e48..670543efcc 100644
--- a/lib/Basic/SourceManager.cpp
+++ b/lib/Basic/SourceManager.cpp
@@ -345,6 +345,14 @@ void SourceManager::clearIDTables() {
   createExpansionLoc(SourceLocation(),SourceLocation(),SourceLocation(), 1);
 }
 
+void SourceManager::invalidateCache(const FileEntry* Entry) {
+  if (ContentCache *&E = FileInfos[Entry]) {
+    E->replaceBuffer(0, /*free*/ true);
+    E = 0;
+  }
+  getFileManager().invalidateCache(Entry);
+}
+
 void SourceManager::initializeForReplay(const SourceManager &Old) {
   assert(MainFileID.isInvalid() && "expected uninitialized SourceManager");
 
diff --git a/lib/Serialization/ModuleManager.cpp b/lib/Serialization/ModuleManager.cpp
index 1dee4d0698..9eaddec604 100644
--- a/lib/Serialization/ModuleManager.cpp
+++ b/lib/Serialization/ModuleManager.cpp
@@ -249,7 +249,9 @@ void ModuleManager::removeModules(
     // safely invalidate it anyway).
     if (LoadedSuccessfully.count(&*victim) == 0 &&
         !PCMCache->tryToRemoveBuffer(victim->FileName))
-      FileMgr.invalidateCache(victim->File);
+      FileMgr.invalidateCache(const_cast<FileEntry*>((*victim)->File));
+
+    delete *victim;
   }
 
   // Delete the modules.
-- 
2.18.0

